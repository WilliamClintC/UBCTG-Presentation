class: part-slide

# Introduction √† <i class="fab fa-r-project"></i>

---

# Installation de <i class="fab fa-r-project"></i>

Site internet officiel&nbsp;: https://www.r-project.org/

> R is a language and environment for statistical computing and graphics.
> It is a GNU project which is similar to the S language and environment which was developed at Bell Laboratories (formerly AT&T, now Lucent Technologies) by John Chambers and colleagues.
> R can be considered as a different implementation of S.
> There are some important differences, but much code written for S runs unaltered under R.
>
> R provides a wide variety of statistical (linear and nonlinear modelling, classical statistical tests, time-series analysis, classification, clustering, ...) and graphical techniques, and is highly extensible.
> The S language is often the vehicle of choice for research in statistical methodology, and R provides an Open Source route to participation in that activity.
>
> One of R‚Äôs strengths is the ease with which well-designed publication-quality plots can be produced, including mathematical symbols and formulae where needed.
> Great care has been taken over the defaults for the minor design choices in graphics, but the user retains full control.

.center.font200[&rArr; [**Download R**](https://cloud.r-project.org/)]

---

# Sauvegarder le code ... Pas l'environnement&nbsp;!

.pull-left.font150[

Les scripts&nbsp;:

* "*standards*" dans un fichier `.R`

* "*Rmarkdown*" dans un fichier `.Rmd`

]

.pull-right.font150[

Les "donn√©es"&nbsp;:

* un objet dans un `.rds`

* une liste d'objet dans un `.Rdata`

]

---

# Utiliser un IDE ("Integrated Development Environment")

.font150[

* RStudio&nbsp;:
    https://www.rstudio.com/products/rstudio/download/#download

* Emacs + ESS&nbsp;:
    https://ess.r-project.org

* vim + Nvim-R&nbsp;:
    https://medium.com/free-code-camp/turning-vim-into-an-r-ide-cd9602e8c217

* Visual Studio Code + vscode-R&nbsp;:
    https://github.com/REditorSupport/vscode-R

]

---

# Faire *table rase* √† chaque d√©marrage&nbsp;!

.font150[

Lorsque vous quittez <i class="fab fa-r-project"></i>&nbsp;:

* Ne pas enregistrer votre espace de travail (*workspace*&ast;)&nbsp;!

Lorsque vous d√©marrez <i class="fab fa-r-project"></i>&nbsp;:

* Ne pas charger l'espace de travail sauvegard√© pr√©c√©demment&nbsp;!

]

.footnote.font150[
&ast; Le *workspace* est automatiquement sauvegard√©/charg√© via un fichier nomm√© `.Rdata` (l√† o√π s'ex√©cute <i class="fab fa-r-project"></i>).
]

---

# Faire *table rase*&nbsp;! Dans Windows

.center[<img src = "content/media/rwindows.png" />]

---

# Faire *table rase*&nbsp;! Dans RStudio (*Tools > Global options*)

.center[<img src = "content/media/rstudio.png" />]

# Faire *table rase*&nbsp;!

.pull-left.font150[
+ Dans un Terminal

```{bash, eval = FALSE}
R --no-save --no-restore-data
```

]

.pull-right.font150[
+ `.bash_profile` / `.bashrc` / ...

```{bash, eval = FALSE}
alias R='R --no-save --no-restore-data'
```

]

---

#  Comment R√©initialiser <i class="fab fa-r-project"></i>&nbsp;? Avec `rm(list = ls())`&nbsp;?

.font150[

> If the first line of your R script is
>
> `rm(list = ls())`
>
> I will come into your office and SET YOUR COMPUTER ON FIRE üî•.
>
> --- Jenny Bryan

]

---

# Que ne fait pas `rm(list = ls())`&nbsp;?

.font150[

* R√©initialiser la session <i class="fab fa-r-project"></i> en cours

* R√©initialiser les `options()`
    &#x2192; `options(stringsAsFactors = FALSE)`&ast;

* R√©initialiser le r√©pertoire de travail
    `getwd()` &#x2192; `setwd()`

* R√©initialiser les extensions <i class="fab fa-r-project"></i> attach√©es

]

.footnote.font150[
&ast; Valeur par d√©faut <i class="fab fa-r-project"></i> v4.0.0 ([Kurt Hornik: stringsAsFactors](https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/)).
]

---

# Mais alors que fait `rm(list = ls())`&nbsp;?

```{r, eval = FALSE, echo = TRUE}
help(rm)
```

.center[<img src = "content/media/rm-doc.png" />]

---

# R√©initialiser <i class="fab fa-r-project"></i>

.font150[

* Dans une console <i class="fab fa-r-project"></i>

    * Via le raccourci `Ctrl+D`

    * Via la fonction `q()` dans une console <i class="fab fa-r-project"></i>

]

---

# R√©initialiser <i class="fab fa-r-project"></i>

.pull-left.font150[

* Dans RStudio&nbsp;:

    * Via le raccourci `Ctrl+Shift+F10`

    * Via le menu
]

.pull-right[
  .center[<img src = "content/media/restartr.png" />]
]

---

# D√©sactiver les fichiers de d√©marrage

.font150[

* `--vanilla` - pour d√©sactiver le chargement de **tous les fichiers** de d√©marrage

* `--no-init-file` - pour d√©sactiver le chargement du fichier `.Rprofile`

* `--no-environ` - pour d√©sactiver le chargement du fichier `.Renviron`

]

---

#  `setwd(...)` en premi√®re ligne d'un script ...

.font150[

> If the first line of your R script is
>
> `setwd("C:\Users\jenny\path\that\only\I\have")`
>
> I will come into your office and SET YOUR COMPUTER ON FIRE üî•.
>
> --- Jenny Bryan

]

---

# Faisons le Point sur `setwd()`&nbsp;!

.pull-left.code150[

```{r, echo = TRUE, eval = FALSE}
library(ggplot2)

setwd("/path/to/a/directory/on/my/laptop/data")

df <- read.delim("data.csv")

p <- ggplot(df, aes(x, y)) + geom_point()

ggsave("../figs/scatterplot.png")
```

]

.pull-right.code150[

```{r, echo = TRUE, eval = FALSE}
library(ggplot2)

setwd("/path/to/a/directory/on/my/laptop/data")

df <- read.delim("data.csv")

p <- ggplot(df, aes(x, y)) + geom_point()

setwd("/path/to/a/directory/on/my/laptop/figs")

ggsave("scatterplot.png")
```

]

---

# L'extension <i class = "fab fa-r-project"></i> `here`

```{r, echo = FALSE}
if (!file.exists(here("content", "media", "here_ahorst.png"))) {
  download.file(
    url = "https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/here.png",
    destfile = here("content", "media", "here_ahorst.png")
  )
}
```

.pull-left[
.center[<img src = "content/media/here_ahorst.png" />]
]

.pull-right.code60[

```{r}
here::here()
here::i_am("radvanced.Rmd")
here::i_am("content/part-0.Rmd")
fs::dir_tree(here::here(), recurse = FALSE)
```

]

---

# Utiliser un Mode "Projet" via un IDE

.font150[

* D√©marrer un projet A&nbsp;:

    1. D√©marre R.

    2. D√©fini le r√©petoire de travail de R comme la racine du projet A.

* Passer d'un projet A √† un project B&nbsp;:

    1. Red√©marre R.

    2. D√©fini le r√©petoire de travail de R comme la racine du projet B.

]

---

# Utiliser un Mode "Projet"

.font150[

* [__"What They Forgot to Teach You About R"__](https://rstats.wtf/project-oriented-workflow.html) --- Jenny Bryan & Jim Hester

* [__"Project-oriented Workflow"__](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/) --- Jenny Bryan

]

---

# Lectures Utiles

.font150[

* [__"Code Smells and Feels"__](https://www.youtube.com/watch?v=7oyiPBjLAWY) --- Jenny Bryan

* [__"Advanced R"__](https://adv-r.hadley.nz/) --- Hadley Wickham

* [__"Project-oriented Workflow"__](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/) --- Jenny Bryan

* [__"R for Data Science"__](https://r4ds.had.co.nz/) --- Garrett Grolemund & Hadley Wickham

* [__"What They Forgot to Teach You About R"__](https://rstats.wtf/) --- Jenny Bryan & Jim Hester

]

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Noms et Valeurs

---

# Affectation

```{r, eval = FALSE}
x <- c(1, 2, 3)
```

"Cr√©e un objet nomm√© 'x', contenant les valeurs 1, 2 et 3" ou plus pr√©cis√©ment&nbsp;:

* Cr√©e un objet de type vecteur `c(1, 2, 3)`.

* Associe cet objet √† un nom `x`.

---

# Affectation

```{r}
x <- c(1, 2, 3)
y <- x
```

```{r}
lobstr::obj_addr(x)
lobstr::obj_addr(y)
```

`y` n'est pas une copie de `x`.
`x` et `y` sont des r√©f√©rences √† l'objet de type vecteur `c(1, 2, 3)`.

---

# Noms Non-syntaxique

<i class="fab fa-r-project"></i> dispose d'un ensemble de r√®gles pour les noms utilisables&nbsp;:

* Contient uniquement des lettres (ASCII, mais pas uniquement), des chiffres, `.` et `_`.

* Ne peut pas d√©buter par des chiffres ou `_`.

* Ne peut pas √™tre un "nom r√©serv√©" (`?Reserved`).

---

# Noms Non-syntaxique

```{r}
_abc <- 1
```

```{r}
TRUE <- "false"
```

```{r}
`_abc` <- 1
```

```{r}
`+` <- 1
```

---

# Exercices

1. Expliquer les relations entre `a`, `b`, `d`, et `e`.
    ```{r, eval = FALSE}
    a <- 1:10
    b <- a
    b -> e
    e <- d <- 1:10
    ```

2. Que donne le code suivant pour importer un "fichier" csv&nbsp;?
    Quel argument faudrait-il utiliser pour avoir les noms des colonnes tels-qu'ils sont&nbsp;?
    ```{r, eval = FALSE}
    read.csv(
      header = TRUE,
      text = "1ere_colonne,deuxi√®me_colonne,troisi√®me colonne\n1,2,3"
    )
    ```

3. Les fonctions `read.*()` utilisent `make.names()`&nbsp;? Quels sont les r√®gles de conversions utilis√©es&nbsp;?

---

# Copie sur Modification ("Copy-on-modify")

```{r}
x <- c(1, 2, 3)
y <- x

y[3] <- 4
x
y
```

La modification de `y` n'a pas modifi√© `x`.
<i class="fab fa-r-project"></i> cr√©e une copie de l'objet r√©f√©renc√© par `x` en modifiant la troisi√®me valeur.
Ce nouvel objet est ensuite r√©f√©renc√© par `y`.

---

# D√©r√©f√©rencement et "Garbage Collection"

```{r}
x <- 1:3
x <- 2:4

rm(x) # D√©r√©f√©rencement

gc() # Force "Garbage Collection"
```

---

# Exercices

1. √Ä quelle ligne, une copie de `a` est effectu√©e&nbsp;?
    ```{r}
    a <- c(1, 5, 3, 2)
    b <- a
    b[[1]] <- 10
    ```

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Vecteurs

---

# Les Vecteurs

* Bool√©en&nbsp;: `TRUE` et `FALSE`.

* Num√©rique

    * Flottant ("double")

        * D√©cimal `0.1234`.

        * Scientifique `1.23e4`.

        * Hexad√©cimal `0xcafe`.

        * Valeurs particuli√®res&nbsp;: `Inf`, `-Inf` et `NaN`.

    * Entier ("integer")&nbsp;: suffixe `L`, *p.ex.*, `123L`, `1.23e4L` et `0xcafeL`.

* Cha√Æne de caract√®res&nbsp;: entour√©es par `"` ou `'`.
    Les caract√®res sp√©ciaux sont √©chapp√©s par `\` (`?Quotes`).

---

# Les Vecteurs

`c()` ("combine") permet de constituer des vecteurs de longueurs sup√©rieurs √† 1.

```{r}
lgl_var <- c(TRUE, FALSE)
int_var <- c(1L, 6L, 10L)
dbl_var <- c(1, 2.5, 4.5)
chr_var <- c("these are", "some strings")
```

Lorsque les √©l√©ments de `c()` sont dit atomiques, le r√©sultat est alors de m√™me nature.

```{r}
c(c(1, 2), c(3, 4))
```

---

# Les Vecteurs

Le type d'un vecteur peut-√™tre d√©termin√© via `typeof()`.

```{r}
typeof(lgl_var)
typeof(int_var)
typeof(dbl_var)
typeof(chr_var)
```

---

# Les Vecteurs

Et sa longueur via `length()`.

```{r}
length(lgl_var)
length(int_var)
length(dbl_var)
length(chr_var)
```

---

# Valeurs Manquantes

<i class="fab fa-r-project"></i> symbolise les valeurs manquantes √† l'aide de `NA` ("not applicable").
Un calcul impliquant `NA` r√©sultera en un `NA`.

```{r}
NA > 5
10 * NA
!NA
```

---

# Valeurs Manquantes

√Ä quelques exceptions.

```{r}
NA ^ 0
NA | TRUE
NA & FALSE
```

---

# Valeurs Manquantes

D√©termination des valeurs manquantes d'un vecteur de fa√ßon "na√Øve".

```{r}
x <- c(NA, 5, NA, 10)
x == NA
```

La bonne approche pour √©viter les erreurs.

```{r}
is.na(x)
```

---

# Valeurs Manquantes

`NA` est la forme "g√©n√©rique", mais il existe un `NA` pour chacun des types&nbsp;:

* Bool√©en&nbsp;: `NA`.

* Num√©rique

    * Flottant ("double")&nbsp;: `NA_real_`.

    * Entier ("integer")&nbsp;: `NA_integer_`.

* Cha√Æne de caract√®res&nbsp;: `NA_character_`.

---

# Test et Conversion de Type

<i class="fab fa-r-project"></i> dispose de fonctions `is.*()` pour tester le type d'un vecteur, mais sont √† utiliser avec pr√©cautions.

`is.logical()`, `is.integer()`, `is.double()` et `is.character()` effectueront bien le test demand√©/attendu.

Ce qui ne sera pas n√©cessairement le cas de `is.vector()`, `is.atomic()` et `is.numeric()`.

```{r, eval = FALSE}
?is.numeric
```

> is.numeric is an internal generic primitive function: you can write methods to handle specific classes of objects, see InternalMethods. It is not the same as is.double. Factors are handled by the default method, and there are methods for classes "Date", "POSIXt" and "difftime" (all of which return false). Methods for is.numeric should only return true if the base type of the class is double or integer and values can reasonably be regarded as numeric (e.g., arithmetic on them makes sense, and comparison should be done via the base type).

---

# Test et Conversion de Type

Un vecteur ne dispose que d'un seul type, c'est-√†-dire, tous les √©l√©ments doivent avoir le m√™me type.

Lorsque les √©l√©ments d'un vecteur sont de plusieurs types, une conversion sera appliqu√©e selon la r√®gle de priorit√©&nbsp;:
`character` &rarr; `double` &rarr; `integer` &rarr; `logical`.

```{r}
x <- c("a", 1)
typeof(x)
str(x)
```

---

# Test et Conversion de Type

La plupart des fonctions math√©matiques r√©alise cette conversion de type (*p.ex.*, `+`, `log`, etc.).

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
# Nombre de "TRUE"
sum(x)
# Proportion de "TRUE"
mean(x)
```

---

# Test et Conversion de Type

Il est possible de convertir explicitement un vecteur avec les fonctions `as.*()`&nbsp;: `as.logical()`, `as.integer()`, `as.double()` et `as.character()`.

<i class="fab fa-r-project"></i> avertira via un avertissement d'un probl√®me lors de la conversion.

```{r}
as.integer(c("1", "1.5", "a"))
```

---

# Exercices

1. D√©terminer le type des vecteurs suivants.
    ```{r, eval = FALSE}
    c(1, FALSE)
    c("a", 1)
    c(TRUE, 1L)
    ```

2. D√©terminer le r√©sultat des comparaisons suivantes.
    ```{r, eval = FALSE}
    1 == "1"
    -1 < FALSE
    "one" < 2
    ```
    Pour quelle raison ces r√©sultats ont √©t√© obtenu&nbsp;?

3. Pourquoi le type par d√©faut de `NA` est bool√©en&nbsp;?

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Attributs

---

# Les Attributs

Les attributs sont des meta-donn√©es stock√©es sont la forme de paire nom/valeur.
Chaque attribut peut √™tre r√©cup√©r√© et d√©fini individuellement via `attr()`, r√©cup√©r√© en masse via `attributes()` ou encore d√©fini en masse via `structure()`.

```{r}
a <- 1:3
attr(a, "x") <- "abcdef"
attr(a, "x")

attr(a, "y") <- 4:6
str(attributes(a))
```

---

# Les Attributs

```{r}
a <- structure(
  1:3,
  x = "abcdef",
  y = 4:6
)
str(attributes(a))
```

---

# Les Attributs

Les attributs sont en g√©n√©ral √©ph√©m√®res, dans le sens o√π ils sont perdus dans la plupart des op√©rations.

```{r}
attributes(a[1])
attributes(sum(a))
```

L√† encore, il y a principalement deux exceptions&nbsp;:

* __noms__ (`names`), un vecteur de cha√Æne de caract√®res donnant le nom de chaque √©l√©ment.

* __dimension__ (`dim`), un vecteur de valeurs enti√®res donnant les dimensions (utilis√© dans la conversion des vecteurs en matrices ou "arrays").

---

# Les Attributs&nbsp;: Noms

Il existe plusieurs fa√ßons de nommer les √©l√©ments d'un vecteur.

* Lors de la cr√©ation.
    ```{r}
    x <- c(a = 1, b = 2, c = 3)
    ```

* Avec `names()` pour affecter des un vecteur de cha√Æne de caract√®res.
    ```{r}
    x <- 1:3
    names(x) <- c("a", "b", "c")
    ```

* Avec `setNames()`, pour r√©aliser la m√™me t√¢che en une seule ligne.
    ```{r}
    x <- setNames(1:3, c("a", "b", "c"))
    ```

---

# Les Attributs&nbsp;: Dimensions

* Les vecteurs sont de dimension `NULL`.
    ```{r}
    dim(1:6)
    ```

* Les matrices sont de dimension `2`.
    ```{r}
    x <- matrix(1:6, nrow = 2, ncol = 3)
    dim(x)
    ```

* Les "arrays" sont de dimension `n`.
    ```{r}
    x <- array(1:12, dim = c(2, 3, 2))
    dim(x)
    ```

---

# Les Attributs&nbsp;: Dimensions

Il est possible de modifier directement les dimensions d'un vecteur pour en modifier la "forme".

```{r}
x <- 1:6
dim(x) <- c(3, 2)
x
```

---

# Les Attributs&nbsp;: Dimensions

```{r, echo = FALSE}
gt(
data = read.csv(header = TRUE, text = 'Vector,Matrix,Array
"names()","rownames(), colnames()","dimnames()"
"length()","nrow(), ncol()","dim()"
"c()","rbind(), cbind()","abind::abind()"
"---","t()","aperm()"
"is.null(dim(x))","is.matrix()","is.array()"')
) %>%
  cols_align() %>%
  opt_all_caps() %>%
  opt_row_striping() %>%
  tab_options(table.width = "100%", table.font.size = "150%")
```

---

# Les Attributs&nbsp;: Dimensions

`str()` est le meilleur moyen d'identifier la "nature" d'un objet.

```{r}
str(1:3)                   # 1d vector
str(matrix(1:3, ncol = 1)) # column vector
str(matrix(1:3, nrow = 1)) # row vector
str(array(1:3, 3))         # "array" vector
```

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Vecteurs (Objets) S3

---

# Les Vecteurs (Objets) S3

`class` est un autre attribut important dans <i class="fab fa-r-project"></i>, il est le fondement du syst√®me objet S3.

Un objet poss√©dant l'attribut `class` devient un __objet S3__ qui r√©agira diff√©remment d'un simple objet au regard d'une fonction dite "g√©n√©rique".

Les principaux vecteurs S3&nbsp;:

* `factor`, permettant de d√©finir des niveaux pour un vecteur.
* `Date`, la date dans un format d√©fini au jour pr√®s.
* `POSIXct`, la date dans un format d√©fini √† la seconde pr√®s.

---

# Les Vecteurs (Objets) S3&nbsp;: Les Facteurs

Un facteur est un vecteur ne pouvant contenir que des valeurs pr√©d√©finies.
Ce type de vecteur est utilis√© pour stocker des donn√©es cat√©gorielles / discr√®tes en se basant sur un vecteur d'entier.

```{r}
x <- factor(c("a", "b", "b", "a"))
x
typeof(x)
```

---

# Les Vecteurs (Objets) S3&nbsp;: Les Facteurs

Un facteur est un vecteur ne pouvant contenir que des valeurs pr√©d√©finies.
Ce type de vecteur est utilis√© pour stocker des donn√©es cat√©gorielles / discr√®tes en se basant sur un vecteur d'entier.

```{r}
attributes(x)
str(x)
```

---

# Les Vecteurs (Objets) S3&nbsp;: Les Facteurs

Les niveaux d'un facteur peuvent √™tre connus, mais pas n√©cessairement observ√©s dans les donn√©es.

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))
```

Ainsi, il est possible de compter les occurrences de l'ensemble des niveaux.

```{r}
table(sex_char)
table(sex_factor)
```

---

# Les Vecteurs (Objets) S3&nbsp;: Les Facteurs

Les facteurs peuvent √©galement √™tre ordonn√©es et se comportent comme des facteurs "classiques".

```{r}
ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
factor( c("b", "b", "a", "c"), levels = c("c", "b", "a"), ordered = TRUE)
```

__Note&nbsp;:__ Les fonctions `read.*()` et `data.frame()` convertissent automatique les vecteurs de cha√Æne de caract√®res en facteurs. Il est recommand√© de d√©sactiver ce comportant `options(stringsAsFactors = FALSE)` (Par d√©faut avec `R > 4.0`).

---

# Exercices

1. Quelle sorte d'objet renvoi `table()`&nbsp;? Quel est son type&nbsp;? Quels sont ses attributs&nbsp;?

2. Qu'arrive-t-il √† un facteur lorsque les niveaux sont modifi√©s&nbsp;?
    ```{r, eval = FALSE}
    f1 <- factor(letters)
    levels(f1) <- rev(levels(f1))
    ```

3. Que fait le code suivant&nbsp;? De quelle fa√ßon `f2` et `f3` diff√©rent-ils de `f1`&nbsp;?
    ```{r, eval = FALSE}
    f2 <- rev(factor(letters))
    f3 <- factor(letters, levels = rev(letters))
    ```

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Listes

---

# Les Listes

√Ä la diff√©rence des vecteurs, les √©l√©ments d'une liste peuvent √™tre de n'importe quel type, il n'est plus question de "coh√©rence de type".

```{r}
l1 <- list(
  1:3,
  "a",
  c(TRUE, FALSE, TRUE),
  c(2.3, 5.9)
)
typeof(l1)
```

---

# Les Listes

√Ä la diff√©rence des vecteurs, les √©l√©ments d'une liste peuvent √™tre de n'importe quel type, il n'est plus question de "coh√©rence de type".

```{r}
str(l1)
```

---

# Les Listes

Chaque √©l√©ment d'une liste, n'est en r√©alit√© qu'une r√©f√©rence √† l'objet.

```{r}
lobstr::obj_size(mtcars)
l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
```

---

# Les Listes

La lev√©e de la contrainte de "coh√©rence de type" fait des listes un type particuli√®rement flexible et de ce fait ne permet pas d'avoir une repr√©sentation g√©n√©rique efficace syst√©matiquement, comme c'est le cas pour les vecteurs.

```{r}
l3 <- list(list(list(1)))
str(l3)
```

---

# Les Listes

`c()` permet de combiner des √©l√©ments dans le cas des listes.

```{r}
l4 <- list(list(1, 2), c(3, 4))
str(l4)
```

```{r}
l5 <- c(list(1, 2), c(3, 4))
str(l5)
```

---

# Test et Conversion de Type

Le `typeof()` d'une liste est `list`. `is.list()` permet de tester si l'objet est une liste quand `as.list()` permet la conversion en liste.

```{r}
list(1:3)
as.list(1:3)
```

---

# Matrices et Arrays

L'attribut `dim` permettait de passer d'un vecteur √† une matrice ou √† un array.
Dans le cas des listes, il permet de passer √† des "matrice-liste" et "array-liste".

```{r}
l <- list(1:3, "a", TRUE, 1.0)
dim(l) <- c(2, 2)
l
l[[1, 1]]
```

---

# Exercices

1. Lister les points de divergences entre un vecteur et une liste.

2. Pourquoi `as.vector()` ne fonctionne pas pour convertir une liste en vecteur&nbsp;? Pourquoi l'usage de `unlist()` est n√©cessaire&nbsp;?

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les `data.frame`

---

# `data.frame`

L'une des classes S3 importante dans <i class="fab fa-r-project"></i> est la classe `data.frame` (`tibble` dans le "tidyverse"), qui repose enti√®rement sur les listes.

Qu'est-ce qu'un `data.frame`&nbsp;?
Un `data.frame` est une liste nomm√©e, de vecteur de m√™me dimension (longueur) avec des attributs `names` (noms des colonnes) et `row.names`.

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])
typeof(df1)
```

---

# `data.frame`

L'une des classes S3 importante dans <i class="fab fa-r-project"></i> est la classe `data.frame` (`tibble` dans le "tidyverse"), qui repose enti√®rement sur les listes.

Qu'est-ce qu'un `data.frame`&nbsp;?
Un `data.frame` est une liste nomm√©e, de vecteur de m√™me longueur avec des attributs `names` (noms des colonnes) et `row.names`.

```{r}
attributes(df1)
```

---

# `data.frame`

Un `data.frame` a donc une structure rectangulaire et dispose de noms pour les lignes et les colonnes.

* `rownames()` pour obtenir le noms des lignes.

* `colnames()` (ou `names()`) pour obtenir le noms des colonnes.

* `nrow()` pour obtenir le nombre de lignes.

* `ncol()` (ou `length()`) pour obtenir le nombre de colonnes.

---

# `data.frame`

La cr√©ation d'un `data.frame` se fait via `data.frame()`.

```{r}
df <- data.frame(
  x = 1:3,
  y = c("a", "b", "c")
)
str(df)
```

---

# `data.frame`

La cr√©ation d'un `data.frame` se fait via `data.frame()`.

```{r}
df <- data.frame(
  x = 1:3,
  y = c("a", "b", "c"),
  stringsAsFactors = TRUE # Par d√©faut dans R < 4.0
)
str(df)
```

---

# `data.frame`

La cr√©ation d'un `data.frame` se fait via `data.frame()`.

```{r}
df <- data.frame(
  x = 1:3,
  y = c("a", "b", "c"),
  stringsAsFactors = FALSE # Par d√©faut dans R > 4.0
)
str(df)
```

---

# `data.frame`

Par d√©faut, un `data.frame` requiert des noms de colonnes syntaxiquement correct.

```{r}
names(data.frame(`1` = 1))
names(data.frame(`1` = 1, check.names = FALSE))
```

---

# `data.frame`

Un `data.frame` requiert que ces √©l√©ments soit de m√™me longueur, quand cela n'est pas respect√© et lorsque c'est possible, les valeurs des vecteurs les plus courts sont recycl√©s.

```{r}
data.frame(x = 1:4, y = 1:2)
data.frame(x = 1:4, y = 1:3)
```

---

# `data.frame`

Les `data.frame` ayant des noms de lignes, il est possible de les d√©finir de plusieurs fa√ßons.

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)
df3
```

---

# `data.frame`

Les `data.frame` ayant des noms de lignes, il est possible de les d√©finir de plusieurs fa√ßons.

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black")
)
rownames(df3) <- c("Bob", "Susan", "Sam")
df3
```

---

# `data.frame`

L'usage des noms de lignes n'est pas recommand√©.

* Le nom des lignes est une donn√©e, pourquoi la stocker diff√©remment&nbsp;?

* Le nom des lignes doit obligatoirement √™tre une cha√Æne de caract√®res.

* Chaque nom de ligne doit-√™tre unique. <i class="fab fa-r-project"></i> s'assurera que ce soit le cas&nbsp;!
    ```{r}
    df3[c(1, 1, 1), ]
    ```

---

# Test et Conversion de Type

`is.data.frame()` permet de tester si l'objet est un `data.frame()` quand `as.data.frame()` permet la conversion.

```{r}
is.data.frame(df1)
```

---

# Exercises

1. Est-il possible d'avoir un `data.frame` avec z√©ro lignes&nbsp;? Et z√©ro colonnes&nbsp;?

2. Que se passe-t-il lorsque des noms lignes avec duplicatas sont d√©finis via `rownames()`&nbsp;?

3. Que donne `t(df)` ou `t(t(df))`&nbsp;? Avec, `df` un objet de classe `data.frame`.

4. Que fait `as.matrix()` sur un `data.frame` dont les colonnes sont de type diff√©rents&nbsp;?

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>`NULL`

---

# `NULL`

`NULL` un objet particulier.

```{r}
typeof(NULL)
length(NULL)
x <- NULL
attr(x, "y") <- 1
```

---

# `NULL`

Il est possible de tester le caract√®re `NULL` d'un objet.

```{r}
is.null(NULL)
```

`NULL` sert √† d√©finir&nbsp;:

* un vecteur vide (*p.ex.*, `c()`).

* un vecteur absent (*p.ex.*, argument non d√©fini d'une fonction).

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>S√©lection

---

# S√©lection Dans un Vecteur

* Entier positif.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[c(3, 1)]
x[c(1, 1)]
x[c(2.1, 2.9)] # Troncature
```

---

# S√©lection Dans un Vecteur

* Entier n√©gatif.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[-c(3, 1)]
x[c(-1, 2)] # Pas de m√©lange
```

---

# S√©lection Dans un Vecteur

* Bool√©en.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]
x[x > 3]
```

---

# S√©lection Dans un Vecteur

* Recyclage des valeurs.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[c(TRUE, FALSE)] # Recyclage
x[c(TRUE, FALSE, TRUE, FALSE)]
```

---

# S√©lection Dans un Vecteur

* Valeur manquante.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[c(TRUE, TRUE, NA, FALSE)]
```

---

# S√©lection Dans un Vecteur

* "Rien".

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[]
```

---

# S√©lection Dans un Vecteur

* Z√©ro.

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

```{r}
x[0]
```

---

# S√©lection Dans un Vecteur

* Avec des "noms".

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
names(x) <- letters[1:4]
```

```{r}
x[c("d", "c", "a")]
x[c("a", "a", "a")]
```

---

# S√©lection Dans un Vecteur

* Avec des "noms", une correspondance parfaite est requise.

```{r}
z <- c(abc = 1, def = 2)
```

```{r}
z[c("a", "d")] # Correspondance parfaite
z[c("abc", "def")]
```

---

# S√©lection Dans une Liste

La s√©lection s'op√®re de la m√™me fa√ßon que sur un vecteur.

* `[`, renvoi une liste.
* `[[` et `$`, renvoient un √©l√©ment d'une liste.

---

# S√©lection Dans une Liste

La s√©lection s'op√®re de la m√™me fa√ßon que sur un vecteur.

* `[`, renvoi une liste.
    ```{r}
    x <- list(2.1, 4.2, 3.3, 5.4)
    x[c(1, 3)]
    x[[2]]
    ```

---

# S√©lection Dans une Liste

La s√©lection s'op√®re de la m√™me fa√ßon que sur un vecteur.

* `[[` et `$`, renvoient un √©l√©ment d'une liste.
    ```{r}
    x <- list(2.1, 4.2, 3.3, 5.4)
    names(x) <- letters[1:4]
    x$a
    x[["b"]]
    ```

---

# S√©lection Dans une Matrice ou Array

La s√©lection peut s'effectuer avec un vecteur, plusieurs vecteurs ou une matrice.

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
a[c(TRUE, FALSE, TRUE), c("B", "A")]
```

---

# S√©lection Dans une Matrice ou Array

Comme les matrices ou arrays ne sont que des vecteurs avec un attribut `dim`, la s√©lection peut se faire directement avec un seul vecteur de position.

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals
vals[c(4, 15)]
```

---

# S√©lection Dans une Matrice ou Array

Il est √©galement possible d'effectuer la s√©lection √† partir d'une matrice donnant la position des dans chacune des dimensions de la matrice ou array que l'on souhaite manipuler.

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select]
```

---

# S√©lection Dans un `data.frame`

Les `data.frame` se comportent comme des listes et comme des matrices.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[df$x == 2, ]
df[c(1, 3), ]
```

---

# S√©lection Dans un `data.frame`

Deux approches pour s√©lectionner les colonnes d'un `data.frame`.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "z")] # approche liste
df[, c("x", "z")] # approche matrice
```

---

# S√©lection Dans un `data.frame`

Attention, ces deux approches ne sont pas tout √† fait √©quivalentes.

```{r}
str(df["x"])
str(df[, "x"])
str(df[, "x", drop = FALSE])
```

---

# Exercices

1. Corriger les erreurs dans les codes suivants.
    ```{r, eval = FALSE}
    mtcars[mtcars$cyl = 4, ]
    mtcars[-1:4, ]
    mtcars[mtcars$cyl <= 5]
    mtcars[mtcars$cyl == 4 | 6, ]
    ```

2. Pourquoi le code suivant renvoi cinq valeurs manquantes&nbsp;? Et avec `x[NA_real_]`&nbsp;?
    ```{r}
    x <- 1:5
    x[NA]
    ```

3. Pourquoi `mtcars[1:20]` produit une erreur alors que `mtcars[1:20, ]` fonctionne&nbsp;? Quelle est la diff√©rence&nbsp;?

4. Que fait `df[is.na(df)] <- 0`&nbsp;? Sur quel principe repose cette commande&nbsp;?

---

# Les Op√©rateurs `[[` et `$`

`[[` renvoi toujours un √©l√©ment plus petit.

```{r}
x <- list(1:3, "a", 4:6)
x[1]
x[[1]]
```

---

# Les Op√©rateurs `[[` et `$`

`$` fonctionne d'une fa√ßon proche de celle de `[[`.

```{r, eval = FALSE}
mitcars$cyl
mitcars[["cyl"]]
```

---

# Les Op√©rateurs `[[` et `$`

Le `$` n'est pas utilisable lorsque le nom de la colonne ou de l'√©l√©ment est stock√©e dans une variable.

```{r}
var <- "cyl"
mtcars$var
mtcars[[var]]
```

---

# Les Op√©rateurs `[[` et `$`

L'op√©rateur `$` permet √©galement une correspondance partiel des noms, contrairement √† `[[` (ou `[`).

```{r}
x <- list(abc = 1)
x$a
x[["a"]]
```

---

# Les Op√©rateurs `slot()` et `@`

Les op√©rateurs `slot()` et `@` sont des op√©rateurs sp√©cifiques des objets de classe S4, ou `slot()` correspond √† `[[` et `@` √† `$`.

---

# Exercices

1. Extraire la troisi√®me valeur de la variable `cyl` du jeu de donn√©es `mtcars`.

2. √Ä partir de la r√©gression lin√©aire `mod <- lm(mpg ~ wt, data = mtcars)`, extraire le nombre de degr√© de libert√©. Puis extraire, le R carr√© du mod√®le (`summary(mod)`).

---

# S√©lection et Affectation

Les op√©rateurs `[`, `[[` et `$` permettent √©galement les affectations ou modifications.

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102)
x
```

**Attention au recyclage des valeurs&nbsp;!**

---

# S√©lection et Affectation

Approche identique pour les listes.

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
y <- list(a = 1, b = 2)
y["b"] <- list(NULL)
str(y)
```

---

# S√©lection et Affectation

Le cas de la s√©lection par "rien", c'est-√†-dire, `df[]`, permet dans le cas d'une affectation de pr√©serv√© la structure d'origine.

```{r}
mtcars[] <- lapply(mtcars, as.integer)
is.data.frame(mtcars)

mtcars <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
```

---

# Exercices

1. Ajouter une colonne `cyl_fct` √† `mtcars` comme une copie de la colonne `cyl`. Quel est le type de la nouvelle colonne&nbsp;? Modifier le type de cette colonne dans un type plus appropri√© pour une analyse de comparaison de groupes d√©fini par `cyl_fct`.

2. Reprendre les fonctions vu au pr√©alable et identifier la structure, le type, la classe et les attributs des objets g√©n√©r√©s par ces fonctions, *p.ex.*, `stats::lm()`, `stats::aov()`, `t.test()`, `ggplot2::ggplot()`, etc.

3. Manipuler les fonctions `str()`, `typeof()`, `dput()`, `attributes()`, `attr()`, `dimnames()`, `dim()`, `rownames()`, `colnames()` et `names()` sur les jeux de donn√©es de `datasets` (`ls(name = "package:datasets")`).

4. Cr√©er une liste, un vecteur, un `data.frame` √† l'aide de la fonction `structure()`.

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Fonctions

---

#  Les Fonctions

Une fonction se d√©compose en trois √©l√©ments&nbsp;:

* Les arguments (`arguments`).

* Le corps (`body`).

* L'environnement (`environment`).

---

# Les Fonctions

```{r}
f <- function(x, y) {
  # Commentaire
  return(x + y)
}
```

```{r}
f <- function(x, y) {
  # Commentaire
  x + y
}
```

---

# Les Fonctions

```{r}
formals(f)
body(f)
environment(f)
```

---

# Les Fonctions

Les fonctions sont des objets au m√™me titre que les vecteurs.

```{r}
attributes(f)
```

---

# Les Fonctions

* Fonction "classique", affect√©e d'un nom.

```{r}
f <- function(x, y) {
  # Commentaire
  x + y
}
f(1, 2)
```

* Fonction anonyme.

```{r}
(function(x, y) x + y)(1, 2)
```

---

# Les Fonctions Compos√©es

```{r}
square <- function(x) x^2
deviation <- function(x) x - mean(x)
x <- runif(100)
```

---

# Les Fonctions Compos√©es: Imbrication

```{r}
sqrt(mean(square(deviation(x))))
```

---

# Les Fonctions Compos√©es: S√©quentiel

```{r}
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out
```

---

# Les Fonctions Compos√©es: "Pipe" `%>%` (`magrittr`)

```{r}
library(magrittr)
x %>%
  deviation() %>%
  square() %>%
  mean() %>%
  sqrt()
```

---

# Exercices

1. `match.fun()` permet de trouver une fonction avec son nom. √Ä partir d'une fonction, est-il possible de trouver son nom&nbsp;?

2. Quelles fonctions permettraient d'identifier si un objet est une fonction et s'il s'agit d'une primitive&nbsp;? Par exemple, `+`, `sum`, `lm` et `t.test`.

3. Quelles sont les composantes d'une fonction&nbsp;? `str`, `attributes`, `typeof`, `class`, etc.

4. Est-il possible de donner des attributs (*c.-√†-d.*, avec `attr`) √† une fonction&nbsp;?

---
class: part-slide

# Fondamentaux "<i class="fab fa-r-project"></i> base"<br>Les Structures de Contr√¥le

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

La structure de contr√¥le "si sinon" s'√©crit sous les formessuivantes&nbsp;:

* `if (condition) action_si_vraie`,
    lorsque l'on ne souhaite rien faire si la condition est fausse.

* `if (condition) action_si_vraie else action_si_fausse`,
    lorsque l'on souhaite d√©finir une action que la condition soit vraie ou fausse.

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

Les structures `if ... else ...` peuvent √™tre imbriqu√©es&nbsp;:

```{r, eval = FALSE}
if (x > 75) {
  "]75, Inf["
} else if (x > 50) {
  "]50, 75]"
} else if (x > 25) {
  "]25, 50]"
} else {
  "]-Inf, 25]"
}
```

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

`if ... else ...` renvoie un r√©sultat comme n'importe quelle fonction.
Ce r√©sultat peut donc √™tre affect√© √† une variable via l'op√©rateur `<-` (ou `=`)&ast;.

```{r}
resultat1 <- if (TRUE) "vrai" else "faux"
resultat1
(resultat2 <- if (FALSE) "vrai" else "faux")
resultat2
```

.footnote[
&ast; Pour des questions de clart√© et lisibilit√© du code, l'affectation globale d'un `if ... else ...` est recommand√© lorsque l'expression tient sur une seule ligne.
]

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

Avec ou sans `else`, un r√©sultat est renvoy√©&nbsp;:

.pull-left[
* "visible"

```{r}
if (FALSE) "vrai" else {}
```

```{r}
(x1 <- if (FALSE) "vrai" else {})
```

```{r}
x1
```

]

.pull-right[
* "invisible"

```{r}
if (FALSE) "vrai"
```

```{r}
(x2 <- if (FALSE) "vrai")
```

```{r}
x2
```
]

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

Une condition doit √™tre un bool√©en (c'est-√†-dire, `TRUE` ou `FALSE`) de longueur 1.

```{r}
if ("FALSE") "vrai"
if (NA) "vrai"
if (logical()) "vrai"
if (1:5) "vrai"
```

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

<i class="fab fa-r-project"></i> autorise cependant l'usage d'un vecteur de bool√©en d'une longueur sup√©rieure √† 1.

```{r}
if (c(FALSE, TRUE)) "vrai"
if (c(TRUE, FALSE)) "vrai"
```

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

<i class="fab fa-r-project"></i> est un langage vectorielle, ainsi il existe `ifelse`.

```{r}
ifelse(c(FALSE, TRUE), "vrai", "faux")
ifelse(c(TRUE, FALSE), "vrai", "faux")
```

--

```{r}
ifelse(1:10 %% 2 == 0, "pair", "impair")
ifelse(1:10 %% 2 == 0, "pair", NA_character_)
```

---

# Les Structures de Contr√¥le&nbsp;: `if ... else ...`

<i class="fab fa-r-project"></i> propage les `NA` dans la sortie du `ifelse`.

```{r}
x <- c(NA, 1:10, NA)
ifelse(x %% 2 == 0, "pair", "impair")
```

---

# Les Structures de Contr√¥le&nbsp;: `switch`

Le `switch` est un cas particulier de `if ... else ...`.

.pull-left[
```{r}
set_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2"
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Option `x` non valide !")
  }
}
```
]

--

.pull-right[
```{r}
set_option <- function(x) {
  switch(x,
    a = "Option 1",
    b = "Option 2",
    c = "Option 3",
    stop("Option `x` non valide !")
  )
}
```
]

La derni√®re instruction (sans nom) devrait contenir une erreur (c'est-√†-dire, `stop("message")`).

```{r}
(switch("c", a = 1, b = 2, stop("Erreur!")))
(switch("c", a = 1, b = 2))
```

---

# Exercices

1. Quel type de vecteurs produisent les instructions suivantes&nbsp;? Quelle est la r√®gle (`?ifelse`)&nbsp;?
    ```{r, eval = FALSE}
    ifelse(TRUE, 1, "no")
    ifelse(FALSE, 1, "no")
    ifelse(NA, 1, "no")
    ```

2. Pour quelle raison les instructions suivantes fonctionnent&nbsp;?
    ```{r, eval = FALSE}
    x <- 1:10
    if (length(x)) "Non vide" else "Vide"
    x <- numeric()
    if (length(x)) "Non vide" else "Vide"
    ```

---

# Les Structures de Contr√¥le&nbsp;: `for (...) ...`

* Les it√©rations √† partir d'un vecteur de valeurs peut se faire via une boucle `for`.

```{r, eval = FALSE}
for (element in vecteur) action
```

--

* L'action `action` est r√©alis√©e une fois par √©l√©ment et donc autant de fois que la longeur de `vecteur`.

```{r}
for (i in 1:3) {
  print(i)
}
```

--

* La valeur de l'indice `i` est stock√©e dans l'environnement courant.

```{r}
i <- "mon indice"
for (i in 1:3) {}
i
```

---

# Les Structures de Contr√¥le&nbsp;: `for (...) ...`

Pour sortir pr√©matur√©ment d'une boucle `for`&nbsp;:

* `next`, passe directement √† l'√©l√©ment suivant de la boucle et continu jusqu'√† la fin.

* `break`, provoque une sortie imm√©diate de la boucle.

```{r}
for (i in 1:10) {
  if (i < 3) next

  print(i)

  if (i > 5) break
}
```

---

# Les Structures de Contr√¥le&nbsp;: `for` oui, mais attention&nbsp;!

.pull-left[
* Initiliaser l'objet et remplir celui-ci, plut√¥t qu'aggr√©ger.

```{r}
x <- 1:10
resultats <- vector("numeric", length(x))
for (i in 1:length(x)) {
  resultats[[i]] <- sum(x[1:i])
}
resultats
```

* Pr√©f√©rer `seq_along(x)` plut√¥t que `1:length(x)`.

```{r}
x <- NULL
1:length(x)
seq_along(x)
```

]

.pull-right[

* Utiliser les fonctions vectorielles quand elles existent.

```{r}
x <- 1:10
cumsum(x)
```

```{r, echo = FALSE, message = FALSE}
plot(bench::mark(
  "for" = {
      x <- 1:10
      resultats <- vector("numeric", length(x))
      for (i in 1:length(x)) {
        resultats[[i]] <- sum(x[1:i])
      }
      resultats
  },
  "cumsum" = {
      x <- 1:10
      cumsum(x)
  }
)) +
  scale_colour_manual(values = rep("white", 10)) +
  labs(x = NULL, y = NULL) +
  theme(
    legend.position = "none",
    axis.text.x = element_markdown(face = "bold", size = rel(2)),
    axis.text.y = element_markdown(face = "bold", size = rel(2))
  )
```

]

---

# Exercices

1. Pourquoi le code suivant fonctionne sans erreurs ou avertissement&nbsp;?
    ```{r, eval = FALSE}
    x <- numeric()
    out <- vector("list", length(x))
    for (i in 1:length(x)) {
      out[i] <- x[i] ^ 2
    }
    out
    ```

2. Que se passe-t-il √† chaque √©tape de la boucle `for`&nbsp;?
    ```{r, eval = FALSE}
    xs <- c(1, 2, 3)
    for (x in xs) {
      xs <- c(xs, x * 2)
    }
    xs
    ```